import gc
import os
import uuid
from typing import Any, Optional

import soundfile as sf

from app.core.config import settings
from app.core.exceptions import TTSError

# Mapping of frontend languages to Kokoro lang_code and voice
LANGUAGE_CONFIG = {
    "English": {"lang_code": "a", "voice": "af_heart"},
    "Spanish": {"lang_code": "e", "voice": "ef_dora"},
    "French": {"lang_code": "f", "voice": "ff_siwis"},
    "Italian": {"lang_code": "i", "voice": "if_sara"},
    "Portuguese": {"lang_code": "p", "voice": "pf_dora"},
}


class TTSService:
    def __init__(self) -> None:
        self.pipeline_object: Optional[Any] = None
        self.current_lang_code: Optional[str] = None

    def load_model(self, lang_code: str = "a") -> None:
        """
        Loads the Kokoro KPipeline for the specified lang_code.
        If a pipeline is already loaded for a different language, it clears it first.
        """
        if self.pipeline_object is not None and self.current_lang_code == lang_code:
            return

        try:
            from kokoro import KPipeline

            # Clear existing pipeline to save memory/VRAM
            if self.pipeline_object is not None:
                print(f"Clearing old pipeline for {self.current_lang_code}")
                self.pipeline_object = None
                gc.collect()  # Help clear memory

            print(f"Loading Kokoro Pipeline for lang_code: {lang_code}")
            self.pipeline_object = KPipeline(
                lang_code=lang_code, repo_id="hexgrad/Kokoro-82M"
            )
            self.current_lang_code = lang_code
        except ImportError:
            print("Kokoro library not installed. Using Mock logic.")
            self.pipeline_object = None
            self.current_lang_code = None

    async def synthesize(
        self,
        text: str,
        target_language: str = "English",
        session_id: Optional[str] = None,
    ) -> str:
        # Get config for the target language, fallback to English
        config = LANGUAGE_CONFIG.get(target_language, LANGUAGE_CONFIG["English"])
        lang_code = config["lang_code"]
        voice = config["voice"]

        # Ensure correct pipeline is loaded
        if self.pipeline_object is None or self.current_lang_code != lang_code:
            self.load_model(lang_code)

        if self.pipeline_object is None:
            # Mock behavior if library is missing
            return "/static/mock_audio.wav"

        try:
            # Generate unique filename
            uid = str(uuid.uuid4())
            filename = f"{session_id}_{uid}.wav" if session_id else f"{uid}.wav"
            output_path = os.path.join(settings.AUDIO_OUTPUT_DIR, filename)

            # Generate audio
            generator = self.pipeline_object(
                text, voice=voice, speed=1, split_pattern=r"\n+"
            )

            has_audio = False
            for i, (gs, ps, audio) in enumerate(generator):
                # Save just the first chunk for MVP or stitch them
                sf.write(output_path, audio, 24000)
                has_audio = True
                break

            if not has_audio:
                raise TTSError(message="No audio generated by Kokoro")

            return f"/static/{filename}"

        except Exception as e:
            if isinstance(e, TTSError):
                raise e
            raise TTSError(message=f"Synthesis failed: {str(e)}")


tts_service = TTSService()
