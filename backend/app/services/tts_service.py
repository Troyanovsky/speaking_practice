"""Text-to-Speech (TTS) service for generating audio from text.

This module provides the TTSService class which handles:
- Dynamic language switching with Kokoro TTS models
- Multi-language support (EN, ES, FR, IT, PT)
- Audio file generation and management
- Memory-efficient model loading and cleanup
"""

import gc
import os
import uuid
from typing import Any, Optional

import soundfile as sf

from app.core.config import settings
from app.core.exceptions import TTSError

# Mapping of frontend languages to Kokoro lang_code and voice
LANGUAGE_CONFIG = {
    "English": {"lang_code": "a", "voice": "af_heart"},
    "Spanish": {"lang_code": "e", "voice": "ef_dora"},
    "French": {"lang_code": "f", "voice": "ff_siwis"},
    "Italian": {"lang_code": "i", "voice": "if_sara"},
    "Portuguese": {"lang_code": "p", "voice": "pf_dora"},
}


class TTSService:
    """Handles text-to-speech synthesis using Kokoro.

    Supports dynamic language switching and memory-efficient
    model management for multi-language audio generation.
    """

    def __init__(self) -> None:
        """Initialize the TTS service."""
        self.pipeline_object: Optional[Any] = None
        self.current_lang_code: Optional[str] = None

    def load_model(self, lang_code: str = "a") -> None:
        """Load the Kokoro KPipeline for the specified language.

        Args:
            lang_code: Language code for Kokoro model (default: "a" for English).
        """
        if self.pipeline_object is not None and self.current_lang_code == lang_code:
            return

        try:
            from kokoro import KPipeline

            # Clear existing pipeline to save memory/VRAM
            if self.pipeline_object is not None:
                print(f"Clearing old pipeline for {self.current_lang_code}")
                self.pipeline_object = None
                gc.collect()  # Help clear memory

            print(f"Loading Kokoro Pipeline for lang_code: {lang_code}")
            self.pipeline_object = KPipeline(
                lang_code=lang_code, repo_id="hexgrad/Kokoro-82M"
            )
            self.current_lang_code = lang_code
        except ImportError:
            print("Kokoro library not installed. Using Mock logic.")
            self.pipeline_object = None
            self.current_lang_code = None

    async def synthesize(
        self,
        text: str,
        target_language: str = "English",
        session_id: Optional[str] = None,
        speed: float = 1.0,
    ) -> str:
        """Synthesize text to audio file.

        Args:
            text: Text to synthesize.
            target_language: Language for synthesis (default: English).
            session_id: Optional session ID for filename prefix.
            speed: Speech speed multiplier (default: 1.0).
                Range: 0.5-2.0 recommended.

        Returns:
            URL path to the generated audio file.

        Raises:
            TTSError: If synthesis fails.
        """
        # Get config for the target language, fallback to English
        config = LANGUAGE_CONFIG.get(target_language, LANGUAGE_CONFIG["English"])
        lang_code = config["lang_code"]
        voice = config["voice"]

        # Ensure correct pipeline is loaded
        if self.pipeline_object is None or self.current_lang_code != lang_code:
            self.load_model(lang_code)

        if self.pipeline_object is None:
            # Mock behavior if library is missing
            return "/static/mock_audio.wav"

        try:
            # Generate unique filename
            uid = str(uuid.uuid4())
            filename = f"{session_id}_{uid}.wav" if session_id else f"{uid}.wav"
            output_path = os.path.join(settings.AUDIO_OUTPUT_DIR, filename)

            # Generate audio with specified speed
            generator = self.pipeline_object(
                text, voice=voice, speed=speed, split_pattern=r"\n+"
            )

            has_audio = False
            for _i, (_gs, _ps, audio) in enumerate(generator):
                # Save just the first chunk for MVP or stitch them
                sf.write(output_path, audio, 24000)
                has_audio = True
                break

            if not has_audio:
                raise TTSError(message="No audio generated by Kokoro")

            return f"/static/{filename}"

        except Exception as e:
            if isinstance(e, TTSError):
                raise e
            raise TTSError(message=f"Synthesis failed: {str(e)}")


tts_service = TTSService()
