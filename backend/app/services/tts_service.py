import os
import uuid
import gc
import soundfile as sf
from typing import Optional
from app.core.config import settings

# Mapping of frontend languages to Kokoro lang_code and voice
LANGUAGE_CONFIG = {
    'English': {'lang_code': 'a', 'voice': 'af_heart'},
    'Spanish': {'lang_code': 'e', 'voice': 'ef_dora'},
    'French': {'lang_code': 'f', 'voice': 'ff_siwis'},
    'Italian': {'lang_code': 'i', 'voice': 'if_sara'},
    'Portuguese': {'lang_code': 'p', 'voice': 'pf_dora'},
}

from app.core.exceptions import TTSError

class TTSService:
    def __init__(self):
        self.pipeline_object = None
        self.current_lang_code = None

    def load_model(self, lang_code: str = 'a'):
        """
        Loads the Kokoro KPipeline for the specified lang_code.
        If a pipeline is already loaded for a different language, it clears it first.
        """
        if self.pipeline_object is not None and self.current_lang_code == lang_code:
            return

        try:
            from kokoro import KPipeline
            
            # Clear existing pipeline to save memory/VRAM
            if self.pipeline_object is not None:
                print(f"Clearing old pipeline for {self.current_lang_code}")
                self.pipeline_object = None
                gc.collect() # Help clear memory
            
            print(f"Loading Kokoro Pipeline for lang_code: {lang_code}")
            self.pipeline_object = KPipeline(lang_code=lang_code,repo_id='hexgrad/Kokoro-82M') 
            self.current_lang_code = lang_code
        except ImportError:
            print("Kokoro library not installed. Using Mock logic.")
            self.pipeline_object = None
            self.current_lang_code = None

    async def synthesize(self, text: str, target_language: str = "English", session_id: Optional[str] = None) -> str:
        # Get config for the target language, fallback to English
        config = LANGUAGE_CONFIG.get(target_language, LANGUAGE_CONFIG['English'])
        lang_code = config['lang_code']
        voice = config['voice']

        # Ensure correct pipeline is loaded
        if self.pipeline_object is None or self.current_lang_code != lang_code:
            self.load_model(lang_code)

        if self.pipeline_object is None:
            # Mock behavior if library is missing
            return "/static/mock_audio.wav"

        try:
            # Generate unique filename
            uid = str(uuid.uuid4())
            filename = f"{session_id}_{uid}.wav" if session_id else f"{uid}.wav"
            output_path = os.path.join(settings.AUDIO_OUTPUT_DIR, filename)
            
            # Generate audio
            generator = self.pipeline_object(text, voice=voice, speed=1, split_pattern=r'\n+')
            
            has_audio = False
            for i, (gs, ps, audio) in enumerate(generator):
                # Save just the first chunk for MVP or stitch them
                sf.write(output_path, audio, 24000)
                has_audio = True
                break 
            
            if not has_audio:
                raise TTSError(message="No audio generated by Kokoro")
            
            return f"/static/{filename}"

        except Exception as e:
            if isinstance(e, TTSError):
                raise e
            raise TTSError(message=f"Synthesis failed: {str(e)}")

tts_service = TTSService()
